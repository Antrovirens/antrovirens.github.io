
<!DOCTYPE html>
<html lang="简体中文" class="loading">
<head><meta name="generator" content="Hexo 3.9.0">
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>基于深度学习的SAR影像分类 - Atrovirens&#39; Café</title>
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="google" content="notranslate">
    <meta name="keywords" content="Antrovirens,"> 
    <meta name="description" content=" 介绍
目前应用于高分辨率遥感影像分类的常用算法,其精度已无法满足大数据环境下的分类要求的问题，对于全新方法的探索十分迫切。



人工神经网络（ANN）是机器学习与人工智能领域的一种模型，ANN分,"> 
    <meta name="author" content="antrovirens"> 
    <link rel="alternative" href="atom.xml" title="Atrovirens&#39; Café" type="application/atom+xml"> 
    <link rel="icon" href="/img/favicon.png"> 
    <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css">
    <link rel="stylesheet" href="/css/diaspora.css">
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
         (adsbygoogle = window.adsbygoogle || []).push({
              google_ad_client: "ca-pub-8691406134231910",
              enable_page_level_ads: true
         });
    </script>
    <script async custom-element="amp-auto-ads" src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
    </script>

    <link href="https://cdn.bootcss.com/KaTeX/0.7.1/katex.min.css" rel="stylesheet">
</head>
</html>
<body class="loading">
    <span id="config-title" style="display:none">Atrovirens&#39; Café</span>
    <div id="loader"></div>
    <div id="single">
    <div id="top" style="display: block;">
    <div class="bar" style="width: 0;"></div>
    <a class="icon-home image-icon" href="javascript:;" data-url="http://yoursite.com"></a>
    <div title="播放/暂停" class="icon-play"></div>
    <h3 class="subtitle">基于深度学习的SAR影像分类</h3>
    <div class="social">
        <!--<div class="like-icon">-->
            <!--<a href="javascript:;" class="likeThis active"><span class="icon-like"></span><span class="count">76</span></a>-->
        <!--</div>-->
        <div>
            <div class="share">
                <a title="获取二维码" class="icon-scan" href="javascript:;"></a>
            </div>
            <div id="qr"></div>
        </div>
    </div>
    <div class="scrollbar"></div>
</div>

    <div class="section">
        <div class="article">
    <div class='main'>
        <h1 class="title">基于深度学习的SAR影像分类</h1>
        <div class="stuff">
            <span>十一月 13, 2019</span>
            
  <ul class="post-tags-list"><li class="post-tags-list-item"><a class="post-tags-list-link" href="/tags/卷积神经网络/">卷积神经网络</a></li><li class="post-tags-list-item"><a class="post-tags-list-link" href="/tags/极化SAR影像/">极化SAR影像</a></li><li class="post-tags-list-item"><a class="post-tags-list-link" href="/tags/遥感影像分类/">遥感影像分类</a></li></ul>


        </div>
        <div class="content markdown">
            <h2 id="介绍"><a class="markdownIt-Anchor" href="#介绍"></a> 介绍</h2>
<p>目前应用于高分辨率遥感影像分类的常用算法,其精度已无法满足大数据环境下的分类要求的问题，对于全新方法的探索十分迫切。</p>
<div align="center">
<img src="https://antrovirens-1-1258258000.cos.ap-shanghai.myqcloud.com/post/191113/1.png" alt="人工神经网络（ANN）">
</div>
<p>人工神经网络（ANN）是机器学习与人工智能领域的一种模型，ANN分类以其强大的非线性映射能力、自主学习等能力受到人们的欢迎，过往通常的遥感分类方法大多属于浅层结构模型，这些浅层结构模型的共同特点是对于原始的输入信号只经过较少层次或者非线性处理来达到信息处理的目的。但是对于一些有着复杂结构的信息源，浅层结构模型处理信息的局限性就会凸显出来。更深的层次结构意味着中间处理时的通道组合越多，拥有更复杂的多层非线性变换，而具有更强的表达与建模能力，即对于复杂信息结构的适应性更好。高分辨率遥感影像的分类是一个复杂的过程，采用浅层结构模型对其进行分类有很大的局限性，当下的大数据环境下，因为神经网络的对噪声数据的高承受能力，对未经训练的数据的模式分类能力，成为遥感影像分类方法的合理选择。</p>
<div align="center">
<img src="https://antrovirens-1-1258258000.cos.ap-shanghai.myqcloud.com/post/191113/2.png" alt="SVM和CNN方法的精度对比">
</div>
<p>卷积神经网络（Convolutional Neural Networks, CNN）是一类是为处理二维形状而特殊设计的，包含卷积计算且具有深度结构的前馈神经网络，是深度学习的代表算法之一，它的网络结构更接近于实际的生物神经网络。卷积神经网络由日本学者在1980年首次提出，时间延迟网络和LeNet-5是最早出现的卷积神经网络；在二十一世纪后，随着深度学习理论的提出和数值计算设备的改进，卷积神经网络得到了快速发展，并被应用于计算机视觉、自然语言处理等领域。它使用了局部感知区域、共享权值和空间或者时间域上的降采样，这种网络结构对平移、比例缩放、倾斜或者共他形式的变形具有高度不变性。</p>
<h2 id="原理"><a class="markdownIt-Anchor" href="#原理"></a> 原理</h2>
<p>在生物界，神经元都会将电信号从一段传递到另一端，沿着突触，将电信号从树突传递到树突。一个神经元接受了电信号，当接受信号超过一定阈值（threshold）被激发后链接电路，产生一个输出信号。</p>
<p>对应的，在建构人工结构时，人工神经网络中的神经元可以接受多个输入信号，并将它们加权相加得到总输入左为输入信号，通过内在的阈值函数计算得到输出结果，可以提供信号给更多的神经元。将这种神经元结构复制并构建形成多个层结构的神经网。对应生物功能，人工神经网络结构拥有一个输入层，接受输入信号之后，在其后隐含的多层结构进行相应的梯度运算，传递到输出层经过一定变换得到输出结果。每一层的节点都与所有下一层的节点通过一定的权重直接相连，通过调整节点之间的连接强度或阈值函数的形状来进行节点之间的强度调节。激活函数又称挤压函数, 因为它将一个较大的输入值域映射到较小的区间0到1。不同的激活函数引入给神经网络模型带入了非线性元素，可以处理更为复杂的问题，实际中较为常用的激活函数主要有三种，Sigmoid, tanh, 和ReLU函数。</p>
<p>ReLU修正线性单元 是现在在深度学习神经网络模型中使用率最高的激活函数，使用它在实际计算中非常高效，收敛速度非常快，但是函数特性可能会导致有一些神经元永远不会被激活，并且这些神经元参数不能被更新。这一般是由于模型参数在初始化的时候采用了全正或者全负的值，或者在后向传播中设置的学习率过高导致的。可以对模型参数使用更高级的初始化方法，比如Xavier方法，以及设置合理的后向传播速率，使用自适应的算法比如Adam算法</p>
<p>神经网络算法中，最为流行的是后向传播（Back—Propagation），根据网络实际输出结果和目标结果的差异，通过迭代地处理训练元组数据集, 更新权重和反映网络预测误差的偏倚，向后传播误差, 将每个元组的网络预测与实际知道的类标号相比较进行学习，对于每个训练样本, 修改权重使得网络预测和实际类之间的均方误差最小。这种修改“后向”进行，即由输出层，经由每个隐藏层，到第一个隐藏层（因此称作后向传播）。尽管不能保证，一般地，权重将最终收敛，学习过程停止。</p>
<p>以一个结构为3x3的，有input、hidden、output层组成的，的神经网络作为例，用wih表示输入层到隐藏层的权重矩阵，who表示隐藏层到输出层的权重矩阵，一次训练运算过程如下</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Inputs：输入函数矩阵</span><br><span class="line">Targets：目标结果矩阵</span><br><span class="line">hidden_inputs = wih*inputs	<span class="comment">#传递到隐含层</span></span><br><span class="line">hidden_outputs = activation_function(hidden_inputs)	<span class="comment">#激活函数</span></span><br><span class="line">final_inputs = who * hidden_outputs	<span class="comment">#传递到输出层</span></span><br><span class="line">final_outputs = activation_function(final_inputs) </span><br><span class="line">output_errors = targets - final_outputs 	<span class="comment">#目标·	偏差值</span></span><br><span class="line">hidden_errors = who.T * output_errors	<span class="comment">#后向传播误差</span></span><br><span class="line">who += learningrate * (output_errors * final_outputs * (<span class="number">1.0</span> - final_outputs)) * hidden_outputs.T	<span class="comment">#更新权重</span></span><br><span class="line">wih += learningrate * (hidden_errors * hidden_outputs * (<span class="number">1.0</span> - hidden_outputs)) * inputs.T</span><br></pre></td></tr></table></figure>
<p>卷积神经网络</p>
<p>卷积神经网络架构主要由卷积层，池化层和全连接层等核心层次构成。<br>
卷积层（Convolution Layer）的主要作用是对输入的数据进行特征提取，通过卷积层中的卷积核（Filter），按照指定的步长扫描输入的数据，进行卷积运算，得到增强后的特征信息。</p>
<div align="center">
<img src="https://antrovirens-1-1258258000.cos.ap-shanghai.myqcloud.com/post/191113/3.png" alt="卷积层">
</div>
<p>池化层（pooling layer）作为卷积神经网络中的一种提取输入数据的核心特征的方式，不仅实现了原始数据的压缩，也大量减少了参与模型数据的参数，提高了一定的计算效率。池化层通过定义一个与步长相等的滑动窗口，提取目标中的重要信息，使整个窗口内的信息量减少。常被用到的有平均池化层和最大池化层，分别取的是窗口内的平均值和最大值。</p>
<div align="center">
<img src="https://antrovirens-1-1258258000.cos.ap-shanghai.myqcloud.com/post/191113/4.png" alt="池化层">
</div>
<p>全连接层的主要作用是将输入图像在经过卷积和池化之后提取的特征进行压缩，并根据压缩的特征完成模型的分类功能，即将输入的图像特征与层内预设好的权重参数相乘，得到一个压缩后的分类结果，并经过激活函数的进一步处理使得结果更明显</p>
<h2 id="研究实现思路"><a class="markdownIt-Anchor" href="#研究实现思路"></a> 研究实现思路</h2>
<p>遥感影像是通过亮度值或像元值的高低差异以及空间变化来表示不同的地物。遥感影像分类就是利用计算机对遥感影像中各类地物的光谱信息和空间信息进行分析，选择作为分类判据的特征，并用一定的手段将特征空间划分为互不重叠的子空间，然后将图像中的各个像元划归到各个子空间去。</p>
<p>CNN将人工神经网络技术和深度学习方法相结合，用一种基于梯度的改进反向传播法来训练网络中的权重，实现了深度学习的多层过滤器网络结构以及过滤器和分类器结合的全局训练算法，其降低了网络模型的复杂度，减少了权值的数量，在视觉图像处理领域进行的实验，得到了很好的效果，目前已成为目前图像识别领域的研究热点。</p>
<p>CNN利用空间关系减少需要学习的参数数目以提高一般神经网络算法的训练性能。CNN的特征监测层通过训练数据来进行学习,避免了显式的特征提取，而是隐式地从训练数据中学习特征，而且同一特征映射面上的神经元权值相同，网络可以并行学习，这也是卷积神经网络相对于其他神经网络的一个优势。在CNN中，图像的一小部分（局部感受区域）作为层级结构的最低层输入，信息再依次传输到其他不同的层，每层通过一个数字滤波器去获取观测显著特征，同时避免了特征提取和分类过程中数据重建的复杂度。</p>
<h2 id="尺度网络搭建"><a class="markdownIt-Anchor" href="#尺度网络搭建"></a> 尺度网络搭建</h2>
<p>获得高质量模型最保险的做法就是增加模型的深度（层数）或者是其宽度（层核或者神经元数但是一般情况下更深或更宽的网络会出现以下问题：<br>
-1. 参数太多，容易过拟合，若训练数据集有限，这一问题更加突出；<br>
-2. 网络越大计算复杂度越大，难以应用；<br>
-3. 网络越深，梯度越往后穿越容易消失，难以优化模型;</p>
<p>GoogLeNet认为根本方法是将全连接甚至一般的卷积都转化为稀疏连接，提出了名为Inception的模块化结构来实现此目的，依据是大量的文献表明可以将稀疏矩阵聚类为较为密集的子矩阵来提高计算性能。GoogLeNet做了更大胆的网络上的尝试而不像VGG继承了LENet以及AlexNet的一些框架，该模型虽然有22层，但参数量只有AlexNet的1/12。</p>
<p>Inception结构在3x3前，5x5前，max pooling后分别加上了1x1的卷积核起到了降低feature map厚度的作用。</p>
<div align="center">
<img src="https://antrovirens-1-1258258000.cos.ap-shanghai.myqcloud.com/post/191113/6.png" alt="池化层">
</div>
<div align="center">
<img src="https://antrovirens-1-1258258000.cos.ap-shanghai.myqcloud.com/post/191113/7.png" alt="池化层">
</div>
<h2 id="裁剪样本"><a class="markdownIt-Anchor" href="#裁剪样本"></a> 裁剪样本</h2>
<p>由于GoogleNet网络模型输入要求为256×256像素，而在分辨率不高的SAR图像中，所代表的范围过大，包含地物很难保持一致，因此对于裁剪后的地物块进行重采样，根据分割对象大小决定对原始数据首先进行2m重采样处理, 并以此为为原始数据。如仍大小不符合输入数据尺寸，可以考虑二次乃至三次的重采样，直到大小符合输入矩阵的大小为止。</p>
<p>为满足不同尺度下SAR图像样本类别的判定，对预处理之后的图像，分别制作2、1、0.5m的训练样本集，构建多尺度网络模型。其中，利用３种不同重采样分辨率的样本进行不同尺度的网络模型的训练后得到的训练精度分别为９４．８９％、９２．６５％和８９．５７％。可以看到，随着样本尺度的降低，模型训练精度随之降低</p>
<p>对原始影像进行上采样并没有增加图像本身包含的信息，在同样的像素数标准下，重采样分 辨率越高，其包含的信息越少。而卷积神经网络的工作方式就是对图像进行不断向更高层次的特 征抽象，因此模型分类性能非常依赖图像包含的有效信息量，图像本身包含的有效信息越丰富， 在同样的网络训练条件下，模型分类性能越好。 通过对验证集的预测实验也证实了这个精度下降 的规律。</p>
<p>针对每个多尺度分割形成的对象，进行内部 样本类别统计，以确定此对象的最终类别属性， 判定原则为多数投票法。即对每个对象中裁取的 所有样本进行类别统计，同一类别样本数最多的 样本类别，即为此对象的类别。实验采用径向基函数神经网络分类算法和经典的复Wishart分类作为对比参考。</p>
<h2 id="进行分类"><a class="markdownIt-Anchor" href="#进行分类"></a> 进行分类</h2>
<div align="center">
<img src="https://antrovirens-1-1258258000.cos.ap-shanghai.myqcloud.com/post/191113/8.png" alt="池化层">
</div>
<p>将采集到的3种尺度的样本分别输入不同尺度GoogleNet网络模型，进行样本所属类别预测。针对每个多尺度分割形成的对象，进行内部样本类别统计，以确定此对象的最终类别属性,判定原则为多数投票法。即对每个对象中裁取的所有样本进行类别统计，同一类别样本数最多的样本类别，即为此对象的类别。</p>
<p>算法的分类结果各地物较为完整,可以更多地考虑不同地物类型的纹理特征而不会对同一种地物类型进行割裂，结合了多尺度分割和深度学习,因此在分割结果中不仅保留了良好的不同地物类型之间的边界,也能够得到较高的分类准确性</p>
<h2 id="精度评定"><a class="markdownIt-Anchor" href="#精度评定"></a> 精度评定</h2>
<p>若要评价某一变化检测技术的优劣，除了人眼对其产生的结果图主观评判之外，还需要把结果图和标准参考图相对比，并通过几个量化的指标来客观评判。变化检测任务本质上是一个分类问题，因此本文中使用相应分类的评价指标来衡量不同变化检测技术性能的优劣。<br>
对一帧遥感影像进行专题分类后需要进行分类精度的评价，评价精度的因子有混淆矩阵、总体分类精度、Kappa系数、错分误差、漏分误差、每一类的制图精度和用户精度等。<br>
混淆矩阵（Confusion Matrix）主要用于比较分类结果和地表真实信息的差异，可以把分类结果的精度显示在一个混淆矩阵里面。混淆矩阵是通过将每个地表真实像元的位置和分类与分类图象中的相应位置和分类像比较计算的。混淆矩阵的每一列代表了一个地表真实分类，每一列中的数值等于地表真实像元在分类图象中对应于相应类别的数量，有像元数和百分比表示两种。<br>
可以将结果分为四类： 真正(True Positive, TP)：被模型分类正确的正样本； 假负(False Negative, FN)：被模型分类错误的正样本； 假正(False Positive, FP)：被模型分类错误的负样本； 真负(True Negative, TN)：被模型分类正确的负样本；</p>
<p>真正率(True Positive Rate, TPR)，又名灵敏度(Sensitivity)：分类正确的正样本个数占整个正样本个数的比例，即：</p>
<pre><code>**TPR = TP / (TP + FN)**
</code></pre>
<p>假负率(False Negative Rate, FNR)：分类错误的正样本的个数占正样本的个数的比例，即：</p>
<pre><code>**TNR = FN / (TP + FN)**
</code></pre>
<p>假正率(False Positive Rate, FPR)：分类错误的负样本个数占整个负样本个数的比例，即：</p>
<pre><code>**FPR = FP / (FP + TN)**
</code></pre>
<p>真负率(True Negative Rate, TNR)：分类正确的负样本的个数占负样本的个数的比例，即：</p>
<pre><code>**TNR = TN / (FP + TN)**
</code></pre>
<p>准确率(Accuracy)：分类正确的样本个数占所有样本个数的比例，即：</p>
<pre><code>**ACCURACY = (TP + TN) / (TP + FN + FP + TN)**
</code></pre>
<p>平均准确率(Average per-class accuracy)：每个类别下的准确率的算术平均，即：</p>
<pre><code>**AVERAGE_ACCURACY = (TPR + TNR) / 2**
</code></pre>
<p>精确率(Precision)：分类正确的正样本个数占分类器分成的所有正样本个数的比例（注意：精确率和准确率不同），即：</p>
<pre><code>**P = TP / (TP + FP)**
</code></pre>
<p>召回率(Recall)：分类正确的正样本个数占正样本个数的比例，即：</p>
<pre><code>**R = TP / (TP + FN)**
</code></pre>
<p>Kappa系数(Kappa coefficient, KC)是另外一种计算分类精度的方法。它是通过把所有地表真实分类中的像元总数（N）乘以混淆矩阵对角线（Xkk）的和，再减去某一类中地表真实像元总数与该类中被分类像元总数之积对所有类别求和的结果，再除以总像元数的平方差减去某一类中地表真实像元总数与该类中被分类像元总数之积对所有类别求和的结果所得到的。kappa的值越高，结果越好</p>
<p>假设图像的总像素为N，参考图像中未改变的像素数量为Nu，改变的像素的数量为Nc。于是我们将参考图像（ground truth）与用算法产生的变化图像进行逐像素比较。<br>
则有：</p>
<pre><code>_Nu=FP+TN
_Nc=FN+TP
_OE=FN+FP
_KC = (PRA−PRE) / (1−PRE)_
</code></pre>
<p>其中：</p>
<pre><code>_PRA = (TP+TN) / N_
_PRE = ((TP + FP) * Nc + (FN + TN) * Nu) / N2_
</code></pre>

            <!--[if lt IE 9]><script>document.createElement('audio');</script><![endif]-->
            <audio id="audio" loop="1" preload="auto" controls="controls" data-autoplay="false">
                <source type="audio/mpeg" src="">
            </audio>
            
                <ul id="audio-list" style="display:none">
                    
                        <li title='0' data-url='https://antrovirens-1-1258258000.cos.ap-shanghai.myqcloud.com/DDBY%20-%20%E9%9D%92%E3%81%84%E7%A9%BA%E3%80%81%E7%99%BD%E3%81%84%E9%9B%B2%E3%80%82%E6%B5%81%E3%82%8C%E3%82%8B%E9%A2%A8%E3%81%8C%E5%BF%83%E5%9C%B0%E8%89%AF%E3%81%8F.mp3'></li>
                    
                        <li title='1' data-url='https://antrovirens-1-1258258000.cos.ap-shanghai.myqcloud.com/DDBY%20-%20Starry%20Memories.mp3'></li>
                    
                        <li title='2' data-url='https://antrovirens-1-1258258000.cos.ap-shanghai.myqcloud.com/DDBY%20-%20Starry%20Memories.mp3'></li>
                    
                        <li title='3' data-url='https://antrovirens-1-1258258000.cos.ap-shanghai.myqcloud.com/TAMUSIC%20-%20%E5%90%91%E3%81%93%E3%81%86%E4%BE%A7%E3%81%AE%E6%9C%88.mp3'></li>
                    
                        <li title='4' data-url='https://antrovirens-1-1258258000.cos.ap-shanghai.myqcloud.com/%E4%B8%8A%E6%B5%B7%E3%82%A2%E3%83%AA%E3%82%B9%E5%B9%BB%E6%A8%82%E5%9B%A3%20-%20%E5%90%91%E3%81%93%E3%81%86%E5%81%B4%E3%81%AE%E6%9C%88.mp3'></li>
                    
                </ul>
            
        </div>
        
    <div id='gitalk-container' class="comment link"
        data-ae='false'
        data-ci='aa8bb51537465fdc96a8'
        data-cs='42a5b0db726d5fd6dd5baef6f452c419ff2634a4'
        data-r='antrovirens.github.io'
        data-o='antrovirens'
        data-a='antrovirens'
        data-d='false'
    >查看评论</div>


    </div>
    
</div>


    </div>
</div>
</body>
<script src="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script>
<script src="//lib.baomitu.com/jquery/1.8.3/jquery.min.js"></script>
<script src="/js/plugin.js"></script>
<script src="/js/diaspora.js"></script>
<link rel="stylesheet" href="/photoswipe/photoswipe.css">
<link rel="stylesheet" href="/photoswipe/default-skin/default-skin.css">
<script src="/photoswipe/photoswipe.min.js"></script>
<script src="/photoswipe/photoswipe-ui-default.min.js"></script>

<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">
    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>
    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">
        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>
        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">
            <div class="pswp__top-bar">
                <!--  Controls are self-explanatory. Order can be changed. -->
                <div class="pswp__counter"></div>
                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
                <button class="pswp__button pswp__button--share" title="Share"></button>
                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>
                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                      <div class="pswp__preloader__cut">
                        <div class="pswp__preloader__donut"></div>
                      </div>
                    </div>
                </div>
            </div>
            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div> 
            </div>
            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>
            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>
            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>
        </div>
    </div>
</div>




</html>
